package Nodapo.JavaCode.Service;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Optional;import java.util.regex.Pattern;import java.util.stream.Collectors;import Nodapo.JavaCode.DataStore.DataStore;import Nodapo.JavaCode.Model.BookModel;import Nodapo.JavaCode.Model.Genre;import Nodapo.JavaCode.Model.ShopModel;public class ShopService {		public Optional<ShopModel> shop;		public Optional<ShopModel> shopModel;	public Optional<BookModel> bookModel;	DataStore dataStore;		public ShopService(){		dataStore = new DataStore();	}	/**	 * 	 * @param shopName	 * @param bookName	 * @param price	 * @return Instance of book (if present), empty response otherwise	 */	public  Optional<BookModel> sellBook(String shopName, String bookName, int price) {				//Get the shops and books from data store		List<ShopModel> shops = dataStore.getShops();		List<BookModel> books = dataStore.getBooks(); 		//Filter those instance of shops and books whose name matches the name supplied by the user		shopModel = shops.stream().filter(x->x.getName().equals(shopName)).findFirst();		bookModel = books.stream().filter(x->x.getTitel().equals(bookName)).findFirst();				//if shop is present and book is present		if(shopModel.isPresent() && bookModel.isPresent()) {				//Iterate over all the books of the shop		for(BookModel book : shopModel.get().getBooks()) {						//check if any book from the store has same title and isbn as that of the book requested by the customer and 			//the price paid by the customer is greater than the price of the book and the quantity of book in shop is > 0			if(book.getTitel().equals(bookModel.get().getTitel()) && book.getisbn13()==bookModel.get().getisbn13() && book.getPrice() <= price && book.getQuantity()>0) {				//calculate the index of particular book in list of books in shop				int index = shopModel.get().getBooks().indexOf(bookModel.get());								//update the quantity of book in shop				shopModel.get().getBooks().get(index).setQuantity(shopModel.get().getBooks().get(index).getQuantity()-1);				//Calculate the current sales of the shop				int currentSales = shopModel.get().getSales();								//increasse the sale of shop by the price of book				shopModel.get().setSales(currentSales + bookModel.get().getPrice());								//return the instance of book				return Optional.of(bookModel.get());			}				}		}		//otherwise return empty response; either shop or book is not present		return Optional.empty();	}		/**	 * 	 * @param genre	 * @return Instance of a book filtered by Genre	 */	public List<BookModel> getBookByGenre(ShopModel shop, Genre genre){				//Filter the books in shop which matches the genre provided by the customer 		List<BookModel> booksByGenre = shop.getBooks()				.stream()				.filter(x->x.getGenre()				.equals(genre))				.collect(Collectors.toList());				return booksByGenre;	}			//Remove duplicate books from the list	public static List<BookModel> removeDuplicate(List<BookModel> books) {		//Write logic to remove duplicates						//Create a map with the key as the title of the book and values as the list of details of the book				Map<String, List<BookModel>> book = books.stream().collect(Collectors.groupingBy(BookModel::getTitel));								//Iterate over the values of the created map				for(List<BookModel> modelList : book.values()) {										//if a particular book title has multiple list of details present; it means there are more than 1 					//instance of book present in original list; they have to be combined					if(modelList.size()>1) {												//Summing the total quantities of book 						int total = modelList.stream().mapToInt(BookModel::getQuantity).sum();						books.forEach(x->{							if(x.getTitel().equals(modelList.get(0).getTitel())) {								x.setQuantity(total);							}						});											}				}							//Removing the duplicate entries from the list			return books.stream().distinct().collect(Collectors.toList());		}		//Add a book to a particular store if its isbn is correct	//isbn is correct if it starts from 978 and after multiplying its digits alternatively by 1 and 3 and then adding the sum is divisible by 10	public void addBooks(String shopName, BookModel bookModel) {				//Get the shop instance from the datastore whose name matches the one supplied by the user		shop = dataStore.getShops().stream().filter(p->p.getName().equals(shopName)).findFirst();		int sum=0;				//if shop is present		if(shop.isPresent()) {				//check for isbn validity		Pattern pattern = Pattern.compile("^[9][7][8][-]([0-9]{10})$");		ArrayList<Integer> list = new ArrayList<>();				//If the isbn of the book is matches the pattern		if(pattern.matcher(bookModel.getisbn13()).matches()) {						//processing the isbn			for(int i=0; i<bookModel.getisbn13().length(); i++) {				if(bookModel.getisbn13().charAt(i)=='-')					continue;				else					list.add(Character.getNumericValue(bookModel.getisbn13().charAt(i)));			}				//multiply each digit of isbn by 1 and 3 alternatively and add them			for(int i=0; i<list.size(); i++) {				if(i%2==1) {					list.set(i, (list.get(i))*3);					sum = sum + (list.get(i));				}				else {					list.set(i,(list.get(i)*1));					sum = sum + (list.get(i));				}			}						//If the sum is divisible by 10; isbn is correct and add the book to the list of books of particular store			if(sum%10==0) {				shop.get().getBooks().add(bookModel);				}			}		}			}	}